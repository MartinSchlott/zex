---
description: Zex - The better Zod
alwaysApply: false
---

# ğŸ§ª Zex â€“ the better Zod

**Ein Zod-kompatibler Validator mit sauberen TypeScript-Types statt Generic-Wrapper-Hell**

## ğŸ¯ Das Problem: Zod's API ist gut, die Types sind MÃ¼ll

Zod hat die **perfekte API** â€“ aber schreckliche TypeScript-Inferenz:

```typescript
// Zod API - perfekt lesbar:
const userSchema = z.object({
  name: z.string().optional(),
  age: z.number(),
  email: z.string().email()
});

// Aber der inferierte Typ ist ein Monster:
type User = z.infer<typeof userSchema>;
// => ZodInfer<ZodObject<{ name: ZodOptional<ZodString>, age: ZodNumber, ... }>>
```

**In VS Code siehst du endlose Generic-Wrapper** statt sauberer Types. Debugging wird zum Alptraum.

## âœ… Die LÃ¶sung: Gleiche API, saubere Types

**Zex behÃ¤lt Zod's perfekte API**, gibt dir aber **clean TypeScript Types**:

```typescript
// Exakt gleiche Schreibweise wie Zod:
const userSchema = zex.object({
  name: zex.string().optional(),
  age: zex.number(),
  email: zex.string().email()
});

// Aber saubere Type-Inferenz:
type User = zex.infer<typeof userSchema>;
// => { name?: string; age: number; email: string }
```

**Kein Wrapper-Hell. Keine Generic-HÃ¶lle. Nur saubere Types.**

## ğŸ”„ Kompatible API (keine 100% Dropâ€‘inâ€‘Garantie)

Zex orientiert sich stark an Zod, ist aber **nicht** 100% Dropâ€‘in kompatibel.

Wichtige Unterschiede:
- **`object()` Default-Modus**: Zex nutzt standardmÃ¤ÃŸig `"strict"` (unbekannte Felder verursachen Fehler). Zod nutzt standardmÃ¤ÃŸig `strip`.
- **`union()` Aufruf**: Zex erwartet Varargs (`zex.union(a, b, c)`), Zod erwartet ein Array (`z.union([a, b, c])`).
- **Beschreibung**: Methode heiÃŸt in Zex `describe(...)` (Doku-Beispiele unten entsprechend angepasst).

## ğŸ—ï¸ Technische Architektur

### Class-basiertes Design ohne Generic-Wrapper

Zex nutzt **Klassen-Vererbung** statt verschachtelter Generics:

```typescript
// Basis-Klasse mit Flag-System:
class ZexBase<T> {
  protected config: ZexConfig = {
    optional: false,
    nullable: false,
    validators: [],
    meta: {}
  };
}

// Konkrete Typen ohne Wrapper:
class ZexString extends ZexBase<string> {
  optional(): ZexString {  // Gibt sich selbst zurÃ¼ck, kein Wrapper!
    return new ZexString({ ...this.config, optional: true });
  }
  
  min(length: number): ZexString {  // Chaining ohne Generic-Hell
    return this.addValidator(minLengthValidator(length));
  }
}
```

### Interne Struktur

```typescript
interface ZexConfig {
  optional: boolean;
  nullable: boolean;
  validators: Array<Validator>;  // min, max, email, uuid, etc.
  defaultValue?: unknown;
  meta: Record<string, any>;     // Beliebige Metadaten, u.a. contentMediaType
}
```

## ğŸ“‹ First-Class Metadata Support

Zex bietet **ergonomische Metadata-Methoden** fÃ¼r JSON Schema:

```typescript
const apiSchema = zex.string()
  .title("Username")
  .describe("User's login name")
  .deprecated(true)
  .format("email")
  .mimeFormat("application/json") // setzt meta.contentMediaType
  .meta({ 
    customField: "value",
    openapi: { example: "john_doe" }
  });
```

**Alle Aufrufe mergen mit dem bestehenden meta-Object:**
- `.title()` â†’ setzt `meta.title`
- `.describe()` â†’ setzt `meta.description`  
- `.mimeFormat()` â†’ setzt `meta.contentMediaType`
- `.meta()` â†’ merged beliebige Keys
- First-class methods fÃ¼r Standard JSON Schema Properties

## ğŸŒ JSON Schema Integration

**Export zu JSON Schema (optional Draft 2020-12 via Parameter):**

```typescript
const schema = zex.object({
  name: zex.string().title("Name"),
  age: zex.number().min(0).max(120)
});

// Einfacher Export:
const jsonSchema = schema.toJsonSchema();

// Mit Parametern fÃ¼r Feinjustierung:
const jsonSchema = schema.toJsonSchema({
  additionalProperties: false,
  $schema: "https://json-schema.org/draft/2020-12/schema" // optional
});
```

## ğŸ”— Union Types Support

```typescript
// Unions ohne Generic-KomplexitÃ¤t:
const statusSchema = zex.union(
  zex.literal("pending"),
  zex.literal("approved"), 
  zex.literal("rejected")
);

type Status = zex.infer<typeof statusSchema>;
// => "pending" | "approved" | "rejected"

// Komplexere Unions:
const dataSchema = zex.union(
  zex.string(),
  zex.number(),
  zex.object({ type: zex.literal("custom") })
);
// Hinweis: Zod nutzt hier ein Array: z.union([ ... ])
// Zex nutzt Varargs: zex.union(a, b, c)
```

## âš¡ Praktisches Beispiel

```typescript
import { zex } from 'zex';

// Schema definieren (identisch zu Zod):
const apiSchema = zex.object({
  userId: zex.string().uuid().title("User ID"),
  data: zex.array(zex.object({
    name: zex.string().min(1).title("Name"),
    age: zex.number().optional().min(0).max(120),
    status: zex.union(
      zex.literal("active"),
      zex.literal("inactive")
    ).default("active")
  })).describe("User data array")
});

// Clean Type-Inferenz:
type ApiRequest = zex.infer<typeof apiSchema>;
// => {
//   userId: string;
//   data: Array<{
//     name: string;
//     age?: number;
//     status: "active" | "inactive";
//   }>;
// }

// Runtime-Validation (Ã¤hnlich zu Zod):
const result = apiSchema.parse(inputData);

// Bessere Fehlermeldungen:
// Statt: "Expected ZodString, received ZodNumber"  
// Zex:   "Field 'data[0].age' expected number, got string"

// JSON Schema Export (ohne default $schema, optional via Parameter):
const jsonSchema = apiSchema.toJsonSchema({
  title: "API Request Schema",
  additionalProperties: false
});
```

## ğŸ¯ Warum Zex besser ist

| Feature | Zod | Zex |
|---------|-----|-----|
| **API** | âœ… Perfekt | âœ… Sehr Ã¤hnlich (kleine Abweichungen, s.o.) |
| **TypeScript Types** | âŒ Wrapper-Hell | âœ… Saubere Types |
| **Debugging** | âŒ UnmÃ¶glich | âœ… Kristallklar |
| **Performance** | âš ï¸ Wrapper-Overhead | âœ… Optimiert |
| **JSON Schema** | âŒ 3rd-party | âœ… Built-in (optional Draft 2020-12 via Option) |
| **Migration** | - | âš ï¸ Weitgehend kompatibel (kein Dropâ€‘in), s. Unterschiede |
| **Metadata** | âš ï¸ Begrenzt | âœ… First-class + flexibel |
| **Unions** | âŒ Generic-Chaos | âœ… Clean Types |

## ğŸ› ï¸ Implementation

**Zex behÃ¤lt Zod's chainable API** bei, verwendet aber intern:

- âœ… **Klassen-Vererbung** statt Generic-Wrapper
- âœ… **Flag-basierte Konfiguration** fÃ¼r optional/nullable
- âœ… **Validator-Arrays** fÃ¼r Runtime-Checks
- âœ… **Flexible Meta-Objects** fÃ¼r JSON Schema
- âœ… **Clean Type-Inferenz** ohne Template-Hell

**Das Resultat:**
- âœ… **Gleiche Entwicklererfahrung** wie Zod
- âœ… **Saubere TypeScript-Inferenz** ohne Wrapper
- âœ… **Bessere Performance** durch optimierte Internals
- âœ… **Nahtlose Migration** von bestehenden Zod-Projekten
- âœ… **Native JSON Schema Support** fÃ¼r APIs

**Zex = Zod's API + Clean Types + Better DX + JSON Schema**

### Hinweis zu BinÃ¤rdaten (ZexBuffer)

Zex nutzt fÃ¼r echte BinÃ¤rfÃ¤higkeit ein eigenes JSONâ€‘Schemaâ€‘Format fÃ¼r Buffer:

```json
{
  "type": "object",
  "format": "buffer",
  "contentMediaType": "image/png"
}
```

Das ist bewusst unorthodox (statt `string`+`contentEncoding`), um klare BinÃ¤râ€‘Semantik zu erhalten. `zex.buffer(mime)` setzt `contentMediaType` automatisch; alternativ kann `.mimeFormat(...)` genutzt werden.