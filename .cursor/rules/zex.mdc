---
description: Zex - The better Zod
alwaysApply: false
---

# üß™ Zex ‚Äì the better Zod

**Ein Zod-kompatibler Validator mit sauberen TypeScript-Types statt Generic-Wrapper-Hell**

## üéØ Das Problem: Zod's API ist gut, die Types sind M√ºll

Zod hat die **perfekte API** ‚Äì aber schreckliche TypeScript-Inferenz:

```typescript
// Zod API - perfekt lesbar:
const userSchema = z.object({
  name: z.string().optional(),
  age: z.number(),
  email: z.string().email()
});

// Aber der inferierte Typ ist ein Monster:
type User = z.infer<typeof userSchema>;
// => ZodInfer<ZodObject<{ name: ZodOptional<ZodString>, age: ZodNumber, ... }>>
```

**In VS Code siehst du endlose Generic-Wrapper** statt sauberer Types. Debugging wird zum Alptraum.

## ‚úÖ Die L√∂sung: Gleiche API, saubere Types

**Zex beh√§lt Zod's perfekte API**, gibt dir aber **clean TypeScript Types**:

```typescript
// Exakt gleiche Schreibweise wie Zod:
const userSchema = zex.object({
  name: zex.string().optional(),
  age: zex.number(),
  email: zex.string().email()
});

// Aber saubere Type-Inferenz:
type User = zex.infer<typeof userSchema>;
// => { name?: string; age: number; email: string }
```

**Kein Wrapper-Hell. Keine Generic-H√∂lle. Nur saubere Types.**

## üîÑ Drop-in Replacement f√ºr Zod

Zex ist als **100% kompatibler Zod-Ersatz** gedacht:

```typescript
// Vorher:
import { z } from 'zod';
const schema = z.string().optional();

// Nachher:
import { zex } from 'zex';  
const schema = zex.string().optional();

// Gleiche API, bessere Types!
```

**Alle Zod-Methoden funktionieren identisch:**
- `zex.string()`, `zex.number()`, `zex.boolean()`
- `zex.object()`, `zex.array()`, `zex.union()`
- `.optional()`, `.nullable()`, `.default()`
- `.email()`, `.min()`, `.max()` usw.

## üèóÔ∏è Technische Architektur

### Class-basiertes Design ohne Generic-Wrapper

Zex nutzt **Klassen-Vererbung** statt verschachtelter Generics:

```typescript
// Basis-Klasse mit Flag-System:
class ZexBase<T> {
  protected config: ZexConfig = {
    optional: false,
    nullable: false,
    validators: [],
    meta: {}
  };
}

// Konkrete Typen ohne Wrapper:
class ZexString extends ZexBase<string> {
  optional(): ZexString {  // Gibt sich selbst zur√ºck, kein Wrapper!
    return new ZexString({ ...this.config, optional: true });
  }
  
  min(length: number): ZexString {  // Chaining ohne Generic-Hell
    return this.addValidator(minLengthValidator(length));
  }
}
```

### Interne Struktur

```typescript
interface ZexConfig {
  optional: boolean;
  nullable: boolean;
  validators: Array<Validator>;  // min, max, email, uuid, etc.
  meta: Record<string, any>;     // Beliebige Metadaten
}
```

## üìã First-Class Metadata Support

Zex bietet **ergonomische Metadata-Methoden** f√ºr JSON Schema:

```typescript
const apiSchema = zex.string()
  .title("Username")
  .description("User's login name")
  .deprecated(true)
  .format("email")
  .mimeFormat("application/json")
  .meta({ 
    customField: "value",
    openapi: { example: "john_doe" }
  });
```

**Alle Aufrufe mergen mit dem bestehenden meta-Object:**
- `.title()` ‚Üí setzt `meta.title`
- `.description()` ‚Üí setzt `meta.description`  
- `.meta()` ‚Üí merged beliebige Keys
- First-class methods f√ºr Standard JSON Schema Properties

## üåê JSON Schema Integration

**Direkter Export zu JSON Schema Draft 2020-12:**

```typescript
const schema = zex.object({
  name: zex.string().title("Name"),
  age: zex.number().min(0).max(120)
});

// Einfacher Export:
const jsonSchema = schema.toJsonSchema();

// Mit Parametern f√ºr Feinjustierung:
const jsonSchema = schema.toJsonSchema({
  additionalProperties: false,
  $schema: "https://json-schema.org/draft/2020-12/schema"
});
```

## üîó Union Types Support

```typescript
// Unions ohne Generic-Komplexit√§t:
const statusSchema = zex.union(
  zex.literal("pending"),
  zex.literal("approved"), 
  zex.literal("rejected")
);

type Status = zex.infer<typeof statusSchema>;
// => "pending" | "approved" | "rejected"

// Komplexere Unions:
const dataSchema = zex.union(
  zex.string(),
  zex.number(),
  zex.object({ type: zex.literal("custom") })
);
```

## ‚ö° Praktisches Beispiel

```typescript
import { zex } from 'zex';

// Schema definieren (identisch zu Zod):
const apiSchema = zex.object({
  userId: zex.string().uuid().title("User ID"),
  data: zex.array(zex.object({
    name: zex.string().min(1).title("Name"),
    age: zex.number().optional().min(0).max(120),
    status: zex.union(
      zex.literal("active"),
      zex.literal("inactive")
    ).default("active")
  })).description("User data array")
});

// Clean Type-Inferenz:
type ApiRequest = zex.infer<typeof apiSchema>;
// => {
//   userId: string;
//   data: Array<{
//     name: string;
//     age?: number;
//     status: "active" | "inactive";
//   }>;
// }

// Runtime-Validation (wie bei Zod):
const result = apiSchema.parse(inputData);

// Bessere Fehlermeldungen:
// Statt: "Expected ZodString, received ZodNumber"  
// Zex:   "Field 'data[0].age' expected number, got string"

// JSON Schema Export:
const jsonSchema = apiSchema.toJsonSchema({
  title: "API Request Schema",
  additionalProperties: false
});
```

## üéØ Warum Zex besser ist

| Feature | Zod | Zex |
|---------|-----|-----|
| **API** | ‚úÖ Perfekt | ‚úÖ Identisch zu Zod |
| **TypeScript Types** | ‚ùå Wrapper-Hell | ‚úÖ Saubere Types |
| **Debugging** | ‚ùå Unm√∂glich | ‚úÖ Kristallklar |
| **Performance** | ‚ö†Ô∏è Wrapper-Overhead | ‚úÖ Optimiert |
| **JSON Schema** | ‚ùå 3rd-party | ‚úÖ Built-in 2020-12 |
| **Migration** | - | ‚úÖ Drop-in Replacement |
| **Metadata** | ‚ö†Ô∏è Begrenzt | ‚úÖ First-class + flexibel |
| **Unions** | ‚ùå Generic-Chaos | ‚úÖ Clean Types |

## üõ†Ô∏è Implementation

**Zex beh√§lt Zod's chainable API** bei, verwendet aber intern:

- ‚úÖ **Klassen-Vererbung** statt Generic-Wrapper
- ‚úÖ **Flag-basierte Konfiguration** f√ºr optional/nullable
- ‚úÖ **Validator-Arrays** f√ºr Runtime-Checks
- ‚úÖ **Flexible Meta-Objects** f√ºr JSON Schema
- ‚úÖ **Clean Type-Inferenz** ohne Template-Hell

**Das Resultat:**
- ‚úÖ **Gleiche Entwicklererfahrung** wie Zod
- ‚úÖ **Saubere TypeScript-Inferenz** ohne Wrapper
- ‚úÖ **Bessere Performance** durch optimierte Internals
- ‚úÖ **Nahtlose Migration** von bestehenden Zod-Projekten
- ‚úÖ **Native JSON Schema Support** f√ºr APIs

**Zex = Zod's API + Clean Types + Better DX + JSON Schema**